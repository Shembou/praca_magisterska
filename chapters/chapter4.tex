\chapter{Budowa środowiska testowego}
W niniejszym rozdziale przedstawiono kluczowe elementy środowiska testowego. W pierwszej kolejności zaprezentowano szczegółową strukturę katalogów projektu wraz z opisem zawartości poszczególnych folderów i plików. Następnie omówiono działanie wybranych aplikacji testowych, których implementację oraz wyniki pomiarów przedstawiono w kolejnym rozdziale.

\section{Struktura plików aplikacji}

Rysunek~\ref{fig:file_structure} przedstawia architekturę przygotowanego środowiska testowego. Projekt składa się z pięciu głównych katalogów, z których każdy odpowiada za odrębny aspekt przeprowadzanych badań.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\textwidth]{images/file_structure}
	\caption{Struktura plików i katalogów w aplikacji.}
	\label{fig:file_structure}
\end{figure}

\subsection{Katalog communication-mechanisms}
Katalog ten zawiera implementacje aplikacji testujących wydajność różnych protokołów komunikacji. Każda aplikacja mierzy czasy odpowiedzi oraz przepustowość dla konkretnego mechanizmu wymiany danych. Wspólna struktura podkatalogów dla wszystkich implementacji obejmuje:
\begin{itemize}
	\item \textbf{src} -- katalog zawierający kod źródłowy aplikacji serwerowej i klienckiej dla danego protokołu,
	\item \textbf{cert.pem} -- lokalny certyfikat SSL/TLS niezbędny do nawiązania bezpiecznego połączenia z wykorzystaniem protokołu HTTP/2,
	\item \textbf{key.pem} -- prywatny klucz kryptograficzny odpowiadający certyfikatowi, wymagany do obsługi szyfrowanej komunikacji,
	\item \textbf{Cargo.toml} -- manifest pakietu w formacie TOML, zawierający metadane projektu, listę zależności oraz parametry kompilacji niezbędne do zbudowania aplikacji w języku Rust.
\end{itemize}

W katalogu communication-mechanisms znajdują się następujące implementacje protokołów:
\begin{itemize}
	\item \textbf{graphql} -- implementacja serwera GraphQL umożliwiającego elastyczne zapytania o dane ze zdefiniowanego schematu,
	\item \textbf{grpc} -- implementacja serwera gRPC opartego na Protocol Buffers, wykorzystującego HTTP/2 do efektywnej komunikacji,
	\item \textbf{REST} -- standardowa implementacja architektury REST API z wykorzystaniem metod HTTP (GET, POST, PUT, DELETE),
	\item \textbf{soap} -- implementacja protokołu SOAP (Simple Object Access Protocol) opartego na wymianie komunikatów XML,
	\item \textbf{websocket} -- implementacja serwera WebSocket umożliwiającego dwukierunkową komunikację w czasie rzeczywistym,
	\item \textbf{websocket\_secure} -- implementacja protokołu WebSocket Secure (WSS) z szyfrowaniem SSL/TLS.
\end{itemize}

\subsection{Katalog data-serialization-formats}
Katalog zawiera aplikacje służące do porównania wydajności procesów serializacji i deserializacji danych w różnych formatach. Każda implementacja mierzy czas potrzebny na przekształcenie struktur danych oraz rozmiar wynikowych reprezentacji. W katalogu znajdują się następujące moduły testowe:
\begin{itemize}
	\item \textbf{avro} -- implementacja testów dla formatu Apache Avro, binarnego systemu serializacji z wbudowanym wsparciem dla schematów danych,
	\item \textbf{bson\_benchmark} -- testy wydajności formatu BSON (Binary JSON), wykorzystywanego między innymi w bazach danych MongoDB,
	\item \textbf{json} -- implementacja testów dla formatu JSON (JavaScript Object Notation), popularnego tekstowego formatu wymiany danych,
	\item \textbf{message-pack} -- testy formatu MessagePack, będącego binarną alternatywą dla JSON o mniejszym rozmiarze danych,
	\item \textbf{protobuf} -- implementacja testów dla Protocol Buffers (Protobuf), binarnego formatu serializacji opracowanego przez Google,
	\item \textbf{xml} -- testy wydajności formatu XML (eXtensible Markup Language), rozszerzalnego języka znaczników.
\end{itemize}

\subsection{Katalog graphs}
Katalog zawiera narzędzia do wizualizacji wyników przeprowadzonych eksperymentów oraz wygenerowane wykresy. Struktura obejmuje:
\begin{itemize}
	\item \textbf{communicationMechanismsGraphsGenerator.py} -- skrypt w języku Python generujący wykresy porównawcze dla testów mechanizmów komunikacji, wizualizujący czasy odpowiedzi oraz przepustowość poszczególnych protokołów,
	\item \textbf{dataSerializationGraphsGenerator.py} -- skrypt w języku Python tworzący wykresy przedstawiające wyniki testów serializacji danych, w tym czasy operacji oraz rozmiary zserializowanych struktur,
	\item \textbf{results} -- katalog przechowujący wygenerowane wykresy w formatach graficznych (PNG, SVG) gotowe do wykorzystania w dokumentacji.
\end{itemize}

\subsection{Katalog target}
Katalog target stanowi standardowy folder roboczy kompilatora Rust, zawierający pliki binarne, biblioteki oraz artefakty pośrednie powstałe w procesie budowania projektu. Zawartość tego katalogu jest automatycznie zarządzana przez narzędzie Cargo i nie wymaga ręcznej modyfikacji.

\subsection{Katalog wasm}
Katalog zawiera programy napisane w języku Rust, które są kompilowane do formatu WebAssembly (WASM). Powstałe moduły binarne są następnie wykorzystywane w środowisku przeglądarki internetowej, umożliwiając uruchomienie kodu o wysokiej wydajności po stronie klienta.

\subsection{Katalog wasm-showcase}
Katalog wasm-showcase zawiera kompletną aplikację webową demonstrującą możliwości technologii WebAssembly. Struktura projektu obejmuje następujące elementy:
\begin{itemize}
	\item \textbf{image-processing} -- katalog zawierający skompilowane do WebAssembly moduły służące do przetwarzania obrazów. Pliki WASM oraz pomocnicze skrypty JavaScript pozwalają na wykonywanie operacji graficznych bezpośrednio w przeglądarce,
	\item \textbf{particle-system} -- katalog z modułami WASM implementującymi system cząsteczek, wykorzystywany do demonstracji wydajności obliczeń graficznych w środowisku webowym,
	\item \textbf{web-worker} -- katalog zawierający skompilowane moduły WASM przeznaczone do uruchomienia w Web Workers, umożliwiające wielowątkowe przetwarzanie danych bez blokowania głównego wątku interfejsu użytkownika,
	\item \textbf{styles} -- katalog ze stylami CSS definiującymi wygląd aplikacji webowej,
	\item \textbf{build.ts} -- natywny skrypt TypeScript odpowiedzialny za proces budowania aplikacji, zawierający logikę kompilacji i optymalizacji zasobów,
	\item \textbf{bun.lock} -- plik blokady rejestrujący dokładne wersje wszystkich zależności projektu oraz ich podzależności, zapewniający powtarzalność budowania aplikacji,
	\item \textbf{bunfig.toml} -- plik konfiguracyjny środowiska uruchomieniowego Bun, zawierający ustawienia dotyczące kompilacji i wykonania projektu,
	\item \textbf{components.json} -- plik konfiguracyjny definiujący strukturę importów komponentów oraz integrację z biblioteką Tailwind CSS,
	\item \textbf{package.json} -- manifest projektu Node.js zawierający listę zależności npm wraz z określonymi wersjami, skrypty budowania oraz metadane aplikacji,
	\item \textbf{README.md} -- plik dokumentacji zawierający szczegółowy opis procesu instalacji, konfiguracji oraz uruchomienia aplikacji,
	\item \textbf{tsconfig.json} -- plik konfiguracyjny kompilatora TypeScript, definiujący opcje transpilacji, ścieżki modułów oraz poziom zgodności ze standardem ECMAScript,
	\item \textbf{bun-env.d.ts} -- plik deklaracji typów TypeScript dla środowiska Bun, zapewniający wsparcie IntelliSense i kontrolę typów,
	\item \textbf{src} -- katalog zawierający pliki źródłowe aplikacji, w tym komponenty React, logikę biznesową oraz pomocnicze moduły,
	\item \textbf{public} -- katalog z zasobami statycznymi (obrazy, ikony, manifesty) udostępnianymi bezpośrednio przez serwer webowy,
	\item \textbf{node\_modules} -- katalog zawierający zainstalowane biblioteki i moduły npm, automatycznie zarządzany przez menedżer pakietów.
\end{itemize}

\subsection{Plik .gitignore}
Plik konfiguracyjny systemu kontroli wersji Git, zawierający listę plików i katalogów wykluczonych z repozytorium. Typowo obejmuje katalogi tymczasowe (target, node\_modules), pliki konfiguracyjne środowiska oraz artefakty kompilacji, które nie powinny być śledzone w historii zmian projektu.

\section{Testy wydajnościowe}

W ramach przygotowanego środowiska testowego przeprowadzono szereg eksperymentów mających na celu obiektywną ocenę wydajności różnych mechanizmów komunikacji oraz formatów serializacji danych. Poniżej przedstawiono szczegółowy opis metodologii testowania poszczególnych grup aplikacji.

\subsection{Aplikacje zawarte w katalogu communication-mechanisms}

Dla każdego zaimplementowanego protokołu komunikacji przeprowadzono cztery kategorie testów wydajnościowych, pozwalających na kompleksową ocenę charakterystyk przesyłania danych:

\begin{enumerate}
	\item \textbf{Transmisja małych pakietów danych} -- test polegający na cyklicznym odpytywaniu serwera o dane o rozmiarze 1~KB. Pomiar ten pozwala ocenić narzut protokołu oraz czas odpowiedzi dla typowych żądań zawierających niewielką ilość informacji.
	
	\item \textbf{Transmisja dużych pakietów danych} -- test analogiczny do poprzedniego, z tą różnicą, że rozmiar przesyłanych danych wynosi 1~MB. Eksperyment ten umożliwia ocenę wydajności protokołów w scenariuszu transferu większych zasobów.
	
	\item \textbf{Head-of-Line Blocking} -- test weryfikujący występowanie zjawiska blokowania głowy kolejki, w którym opóźnienie w przetwarzaniu jednego żądania wpływa na obsługę kolejnych żądań w ramach tego samego połączenia. Testom został poodany tylko protokół HTTP1.1 oraz HTTP2.
	
	\item \textbf{Strumieniowanie danych} -- test przeprowadzany wyłącznie dla protokołów wspierających tryb strumieniowy (streaming). Ocenie podlega efektywność przesyłania danych w sposób ciągły, bez konieczności oczekiwania na kompletną odpowiedź serwera. Testom został poodany tylko protokół HTTP1.1 oraz HTTP2.
\end{enumerate}

\subsection{Aplikacje zawarte w katalogu data-serialization-formats}

Dla każdej z zaimplementowanych bibliotek serializacji danych przeprowadzono pomiary wydajności na podstawie ustandaryzowanej struktury danych. W celu zapewnienia porównywalności wyników, wszystkie testy wykorzystują identyczny zestaw danych testowych składający się z kolekcji 1000 obiektów użytkowników wraz z metadanymi.

Struktura danych testowych jest generowana w następujący sposób:

\begin{lstlisting}[style=rustcode, caption={Struktura danych wykorzystana w testach serializacji.}, label={lst:user_struct}]
	let count = 1000;
	let users: Vec<User> = (0..count)
	.map(|i| User {
		id: i as i64,
		name: format!("User {}", i),
		email: format!("user{}@example.com", i),
		age: 20 + (i % 50) as i32,
		is_active: i % 2 == 0,
		tags: vec![
		"tag1".to_string(),
		"tag2".to_string(),
		"tag3".to_string(),
		],
	})
	.collect();
	
	UserCollection {
		users,
		metadata: Metadata {
			version: "1.0.0".to_string(),
			created_at: "2025-01-23T00:00:00Z".to_string(),
			total_count: count,
		},
	}
\end{lstlisting}

Każdy obiekt użytkownika zawiera kompletny zestaw atrybutów: identyfikator liczbowy, nazwę, adres email, wiek, status aktywności oraz listę trzech tagów. Dodatkowo, kolekcja jest wzbogacona o metadane zawierające wersję struktury danych, znacznik czasu utworzenia oraz łączną liczbę elementów. Taka konstrukcja zapewnia reprezentatywny zestaw różnorodnych typów danych (liczby całkowite, ciągi znaków, wartości logiczne, kolekcje) występujących w rzeczywistych zastosowaniach.

Dla każdego formatu serializacji mierzono następujące parametry wydajnościowe:

\begin{enumerate}
	\item \textbf{Czas serializacji} -- czas potrzebny na przekształcenie struktury danych z reprezentacji obiektowej języka Rust do formatu serializowanego. Pomiar wyrażony w milisekundach (ms) i uśredniony na podstawie wielokrotnych iteracji.
	
	\item \textbf{Czas deserializacji} -- czas wymagany do odtworzenia struktury obiektowej z danych w formacie serializowanym. Pomiar wyrażony w milisekundach (ms) i uśredniony na podstawie wielokrotnych iteracji.
	
	\item \textbf{Rozmiar zserializowanych danych} -- całkowita wielkość danych po procesie serializacji, wyrażona w bajtach (B). Parametr ten pozwala ocenić efektywność kompresji oraz narzut protokołu dla różnych formatów wymiany danych.
\end{enumerate}

Wykorzystanie identycznego zestawu danych testowych dla wszystkich formatów serializacji umożliwia obiektywne porównanie ich wydajności oraz charakterystyk w zakresie rozmiaru wynikowych struktur danych.

\subsection{Aplikacje zawarte w katalogu wasm oraz wasm-showcase}

Katalogi \textit{wasm} oraz \textit{wasm-showcase} obejmują zbiór aplikacji eksperymentalnych napisanych w języku Rust, które zostały skompilowane do formatu WebAssembly (WASM) z wykorzystaniem narzędzia \textit{wasm-pack}. Celem tych aplikacji jest analiza wpływu wykorzystania technologii WebAssembly na wydajność wykonywania obliczeń po stronie klienta w środowisku przeglądarki internetowej.

W ramach przeprowadzonych eksperymentów porównywany jest czas wykonania wybranych operacji matematycznych realizowanych bezpośrednio w języku JavaScript oraz analogicznych operacji wykonywanych przez skompilowane moduły WebAssembly. Takie zestawienie umożliwia ocenę potencjalnych korzyści wynikających z wykorzystania kodu natywnego kompilowanego do WASM w kontekście obliczeń o zwiększonej złożoności.

Testy zostały przeprowadzone z wykorzystaniem dwóch interfejsów programistycznych dostępnych w środowisku webowym:
\begin{itemize}
	\item \textbf{Canvas API} -- wykorzystywanego do wykonywania obliczeń związanych z przetwarzaniem grafiki oraz renderowaniem dynamicznych scen, co pozwala ocenić wydajność obliczeń realizowanych w głównym wątku aplikacji,
	\item \textbf{Web Workers API} -- umożliwiającego uruchamianie modułów WebAssembly w osobnych wątkach roboczych, co pozwala na analizę wpływu przetwarzania równoległego na czas wykonania obliczeń oraz responsywność interfejsu użytkownika.
\end{itemize}

Zastosowanie zarówno Canvas API, jak i Web Workers pozwala na kompleksową ocenę wydajności modułów WebAssembly w różnych scenariuszach użycia, obejmujących zarówno obciążenie głównego wątku aplikacji, jak i przetwarzanie asynchroniczne. Wyniki uzyskane w ramach tych testów stanowią podstawę do dalszej analizy porównawczej przedstawionej w kolejnym rozdziale pracy.